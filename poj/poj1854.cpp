#include <iostream>
#include<cmath>
using namespace std;

int main()
{
    int a,b,p[10]={0},c[10]={0},f=0,sum=1;
    bool flag;
    for(int i=3;i<=sqrt(a);i+=2)
    {   flag=true;
        for(int j=3;j<=sqrt(i);j+=2)
        {
            if(i%j==0)
            {
                flag=false;
            }
        }
        if(!flag)
        {
            continue;
        }
        else
        {
           if(a%i==0)
           {
               int k=1;
               p[f++]=i;
               a/=i;
               while(1)
               {
                   if(a%i==0)
                   {
                       a/=i;
                       ++k;
                   }
                   else
                   {
                       break;
                   }
               }
               c[f-1]=k*b;
           }


        }

    }
    for(int i=0;p[i]!=0;++i)
    {

        sum=sum*(pow(p[i],c[i]+1)-1)/(p[i]-1);
    }
    cout<<sum;
    return 0;
}
/*3: 用递归二分求等比数列1+pi+pi^2+pi^3+...+pi^n：

（1）若n为奇数,一共有偶数项，则：
      1 + p + p^2 + p^3 +...+ p^n

      = (1+p^(n/2+1)) + p * (1+p^(n/2+1)) +...+ p^(n/2) * (1+p^(n/2+1))
      = (1 + p + p^2 +...+ p^(n/2)) * (1 + p^(n/2+1))

上式红色加粗的前半部分恰好就是原式的一半，那么只需要不断递归二分求和就可以了，后半部分为幂次式，将在下面第4点讲述计算方法。

 

（2）若n为偶数,一共有奇数项,则:
      1 + p + p^2 + p^3 +...+ p^n

      = (1+p^(n/2+1)) + p * (1+p^(n/2+1)) +...+ p^(n/2-1) * (1+p^(n/2+1)) + p^(n/2)
      = (1 + p + p^2 +...+ p^(n/2-1)) * (1+p^(n/2+1)) + p^(n/2);

   上式红色加粗的前半部分恰好就是原式的一半，依然递归求解

 

4：反复平方法计算幂次式p^n

   这是本题关键所在，求n次幂方法的好坏，决定了本题是否TLE。

   以p=2，n=8为例

   常规是通过连乘法求幂，即2^8=2*2*2*2*2*2*2*2

   这样做的要做8次乘法

 

   而反复平方法则不同，

   定义幂sq=1，再检查n是否大于0，

While，循环过程若发现n为奇数，则把此时的p值乘到sq

{

   n=8>0 ，把p自乘一次， p=p*p=4     ，n取半 n=4

   n=4>0 ，再把p自乘一次， p=p*p=16   ，n取半 n=2

n=2>0 ，再把p自乘一次， p=p*p=256  ，n取半 n=1，sq=sq*p

n=1>0 ，再把p自乘一次， p=p*p=256^2  ，n取半 n=0，弹出循环

}

则sq=256就是所求，显然反复平方法只做了3次乘法
 ————————————————
版权声明：本文为CSDN博主「小優YoU」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lyy289065406/article/details/6648539
